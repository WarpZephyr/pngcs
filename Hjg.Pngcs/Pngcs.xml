<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Pngcs</name>
    </assembly>
    <members>
        <member name="T:Hjg.Pngcs.BitDim">
            <summary>
            A bit scaler between types, moving the most significant bits around.
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.ChunkHelper">
            <summary>
            Static utility methods for Chunks.
            </summary>
            <remarks>
            Client code should rarely need this, see PngMetada and ChunksList.
            </remarks>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkHelper.ToBytes(System.String)">
            <summary>
            Converts to bytes using Latin1 (ISO-8859-1)
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkHelper.ToString(System.Byte[])">
            <summary>
            Converts to String using Latin1 (ISO-8859-1)
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkHelper.ToString(System.Byte[],System.Int32,System.Int32)">
            <summary>
             Converts to String using Latin1 (ISO-8859-1)
            </summary>
            <param name="bytes"></param>
            <param name="offset"></param>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkHelper.ToBytesUTF8(System.String)">
            <summary>
            Converts to bytes using UTF-8
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkHelper.ToStringUTF8(System.Byte[])">
            <summary>
            Converts to string using UTF-8
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkHelper.ToStringUTF8(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts to string using UTF-8
            </summary>
            <param name="bytes"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkHelper.WriteBytes(System.IO.Stream,System.Byte[])">
            <summary>
            Simplifies writing an array of bytes to a stream.
            </summary>
            <param name="stream">The stream to write to.</param>
            <param name="bytes">The bytes to write.</param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkHelper.IsCritical(System.String)">
            <summary>
            Whether or not a chunk is critical, specified by the first letter being uppercase.
            </summary>
            <param name="id">The ID to check.</param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkHelper.IsPublic(System.String)">
            <summary>
            Whether or not a chunk is public, specified by the second letter being uppercase.
            </summary>
            <param name="id">The ID to check.</param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkHelper.IsSafeToCopy(System.String)">
            <summary>
            Whether or not a chunk is safe to copy, specified by the fourth letter being lowercase.
            </summary>
            <param name="id">The ID to check.</param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkHelper.IsUnknown(Hjg.Pngcs.Chunks.PngChunk)">
            <summary>
            We consider a chunk as "unknown" if our chunk factory (even when it has been augmented by client code) doesn't recognize it
            </summary>
            <param name="chunk"></param>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkHelper.PosNullByte(System.Byte[])">
            <summary>
            Finds position of null byte in array
            </summary>
            <param name="bytes"></param>
            <returns>-1 if not found</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkHelper.ShouldLoad(System.String,Hjg.Pngcs.Chunks.ChunkLoadBehavior)">
            <summary>
            Decides if a chunk should be loaded, according to a ChunkLoadBehavior.
            </summary>
            <param name="id"></param>
            <param name="behavior"></param>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkHelper.FilterList(System.Collections.Generic.List{Hjg.Pngcs.Chunks.PngChunk},Hjg.Pngcs.Chunks.IChunkPredicate)">
            <summary>
            Filters a list of Chunks, keeping those which match the predicate
            </summary>
            <remarks>The original list is not altered</remarks>
            <param name="list"></param>
            <param name="predicateKeep"></param>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkHelper.TrimList(System.Collections.Generic.List{Hjg.Pngcs.Chunks.PngChunk},Hjg.Pngcs.Chunks.IChunkPredicate)">
            <summary>
            Filters a list of Chunks, removing those which match the predicate.
            </summary>
            <remarks>The original list is not altered.</remarks>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkHelper.Equivalent(Hjg.Pngcs.Chunks.PngChunk,Hjg.Pngcs.Chunks.PngChunk)">
            <summary>
            Ad-hoc criteria for 'equivalent' chunks.
            </summary>
             <remarks>
            Two chunks are equivalent if they have the same Id AND either:
            1. they are Single
            2. both are textual and have the same key
            3. both are SPLT and have the same palette name
            Bear in mind that this is an ad-hoc, non-standard, nor required (nor wrong)
            criterion. Use it only if you find it useful. Notice that PNG allows to have
            repeated textual keys with same keys.
            </remarks>        
            <param name="c1">Chunk1</param>
            <param name="c2">Chunk1</param>
            <returns>true if equivalent</returns>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.ChunksList">
            <summary>
            All chunks that form an image, read or to be written.<br/>
            http://www.w3.org/TR/PNG/#table53
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunksList._chunks">
            <summary>
             Includes all chunks, but IDAT is a single pseudo chunk without data
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunksList._imageInfo">
            <summary>
            Basic image info, used for writing.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksList.#ctor(Hjg.Pngcs.ImageInfo)">
            <summary>
            Creates a new <see cref="T:Hjg.Pngcs.Chunks.ChunksList"/> from the given <see cref="T:Hjg.Pngcs.ImageInfo"/>.
            </summary>
            <param name="imageInfo">The image info.</param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksList.GetChunksKeys">
            <summary>
            Keys of processed (read or written) chunks.
            </summary>
            <returns>key:chunk id, val: number of occurrences</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksList.GetChunks">
            <summary>
            Returns a copy of the chunk list (but the chunks are not copied) .
            </summary>
            <remarks>
            This should not be used for general metadata handling.
            </remarks>
            <returns>A new list of the same chunks.</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksList.AppendReadChunk(Hjg.Pngcs.Chunks.PngChunk,System.Int32)">
            <summary>
            Adds chunk in next position. This is used only by the pngReader
            </summary>
            <param name="chunk"></param>
            <param name="chunkGroup"></param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksList.GetListById(System.String)">
            <summary>
            All chunks with this ID
            </summary>
            <remarks>The GetBy... methods never include queued chunks</remarks>
            <param name="id"></param>
            <returns>List, empty if none</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksList.GetListById(System.String,System.String)">
            <summary>
            Same as ID, but we an additional discriminator for textual keys
            </summary>
            <remarks>If innerid!=null and the chunk is PngChunkTextVar or PngChunkSPLT, it's filtered by that id</remarks>
            <param name="id"></param>
            <param name="innerid">Only used for text and SPLT chunks</param>
            <returns>List, empty if none</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksList.GetById(System.String)">
            <summary>
            Returns only one chunk 
            </summary>
            <param name="id"></param>
            <returns>First chunk found, null if not found</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksList.GetById(System.String,System.Boolean)">
            <summary>
            Returns only one chunk
            </summary>
            <param name="id"></param>
            <param name="failIfMultiple">true, and more than one found: exception</param>
            <returns>null if not found</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksList.GetById1(System.String,System.String,System.Boolean)">
            <summary>
            Sames as <c>GetById1(String id, bool failIfMultiple)</c> but allows an additional innerid
            </summary>
            <param name="id"></param>
            <param name="innerid"></param>
            <param name="failIfMultiple">true, and more than one found: exception</param>
            <returns>null if not found</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksList.GetEquivalent(Hjg.Pngcs.Chunks.PngChunk)">
            <summary>
            Finds all chunks "equivalent" to this one
            </summary>
            <param name="chunk"></param>
            <returns>Empty if nothing found</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksList.ToString">
            <summary>
            Only the amount of chunks
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksList.ToStringFull">
            <summary>
            Detailed information for debugging.
            </summary>
            <returns>Debugging information.</returns>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.ChunkLoadBehavior">
            <summary>
            Defines what to do with non-critical chunks when reading.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunkLoadBehavior.LOAD_CHUNK_NEVER">
            <summary>
            All non-critical chunks are skipped.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunkLoadBehavior.LOAD_CHUNK_KNOWN">
            <summary>
            Load chunk if 'known' (registered with the factory).
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunkLoadBehavior.LOAD_CHUNK_IF_SAFE">
            <summary>
            Load chunk if 'known' or safe to copy.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunkLoadBehavior.LOAD_CHUNK_ALWAYS">
            <summary>
            Load chunks always.<br/>
            Notice that other restrictions might apply, see <see cref="P:Hjg.Pngcs.PngReader.SkipChunkMaxSize"/> <see cref="P:Hjg.Pngcs.PngReader.SkipChunkIds"/>.
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.ChunkRaw">
             <summary>
             Wraps raw chunk data.
             </summary>
             <remarks>
             Short lived object, to be created while serialing/deserializing.<br/>
             Do not reuse it for different chunks.<br/>
             http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html
            </remarks>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunkRaw.Length">
            <summary>
            The length counts only the data field, not itself, the chunk type code, or the CRC.<br/>
            Zero is a valid length.<br/>
            <br/>
            Although encoders and decoders should treat the length as unsigned, its value must not exceed 2^31-1 bytes.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunkRaw.IdBytes">
            <summary>
            Chunk Id, as array of 4 bytes
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunkRaw.Data">
            <summary>
            Raw data, crc not included
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunkRaw.crcValue">
            <summary>
            The CRC value of the chunk.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkRaw.#ctor(System.Int32,System.Byte[],System.Boolean)">
            <summary>
            Creates an empty raw chunk.
            </summary>
            <param name="length">The length of data within the chunk.</param>
            <param name="idbytes">The ID of the chunk.</param>
            <param name="alloc">Whether or not to pre-allocate the data buffer.</param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkRaw.ComputeCrc">
            <summary>
            Called after setting data, before writing to output.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkRaw.WriteChunk(System.IO.Stream)">
            <summary>
            Writes this chunk to an output <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="output">The stream to write to.</param>
            <exception cref="T:System.IO.InvalidDataException">The chunk ID was invalid.</exception>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkRaw.ReadChunkData(System.IO.Stream,System.Boolean)">
            <summary>
            Position before: just after chunk id. positon after: after crc Data should
            be already allocated. Checks CRC Return number of byte read.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkRaw.ToMemoryStream">
            <summary>
            Gets the data as a new <see cref="T:System.IO.MemoryStream"/>.
            </summary>
            <returns>A new <see cref="T:System.IO.MemoryStream"/>.</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkRaw.ToString">
            <summary>
            The ID and length of this chunk.
            </summary>
            <returns>The ID and length of this chunk</returns>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.ChunksListForWrite">
             <summary>
             Chunks written or queued to be written 
             http://www.w3.org/TR/PNG/#table53
             </summary>
            
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunksListForWrite._queuedChunks">
            <summary>
            Unwritten chunks, does not include IHDR, IDAT, END, perhaps yes PLTE.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksListForWrite.GetQueuedById(System.String)">
            <summary>
            Same as <c>getById()</c>, but looking in the queued chunks
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksListForWrite.GetQueuedById(System.String,System.String)">
            <summary>
            Same as <c>GetById()</c>, but looking in the queued chunks
            </summary>
            <param name="id"></param>
            <param name="innerid"></param>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksListForWrite.GetQueuedById1(System.String,System.String,System.Boolean)">
            <summary>
            Same as <c>GetById()</c>, but looking in the queued chunks
            </summary>
            <param name="id"></param>
            <param name="innerid"></param>
            <param name="failIfMultiple"></param>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksListForWrite.GetQueuedById1(System.String,System.Boolean)">
            <summary>
            Same as <c>GetById1()</c>, but looking in the queued chunks
            </summary>
            <param name="id"></param>
            <param name="failIfMultiple"></param>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksListForWrite.GetQueuedById1(System.String)">
            <summary>
            Same as getById1(), but looking in the queued chunks
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksListForWrite.RemoveChunk(Hjg.Pngcs.Chunks.PngChunk)">
             <summary>
            Remove Chunk: only from queued 
             </summary>
             <remarks>
             WARNING: this depends on chunk.Equals() implementation, which is straightforward for SingleChunks. For 
             MultipleChunks, it will normally check for reference equality!
             </remarks>
             <param name="c"></param>
             <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksListForWrite.Queue(Hjg.Pngcs.Chunks.PngChunk)">
            <summary>
            Adds a chunk to the queue.
            </summary>
            <remarks>Does not check for duplicated chunks.</remarks>
            <param name="chunk">The chunk to queue.</param>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksListForWrite.ShouldWrite(Hjg.Pngcs.Chunks.PngChunk,System.Int32)">
            <summary>
            This should be called only for ancillary chunks and PLTE (groups 1 - 3 - 5).
            </summary>a
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunksListForWrite.GetQueuedChunks">
            <summary>
            Unwritten chunks, does not include IHDR, IDAT, END, perhaps yes PLTE.
            </summary>
            <returns>This is not a copy, don't modify.</returns>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.ChunkCopyBehaviour">
            <summary>
            Behaviours for chunks transfer when reading and writing.
            </summary>
            <remarks>
            They are bitmasks, can be OR-ed.
            </remarks>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunkCopyBehaviour.COPY_NONE">
            <summary>
            Don't copy any chunk.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunkCopyBehaviour.COPY_PALETTE">
            <summary>
            Copy the Palette, if present.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunkCopyBehaviour.COPY_ALL_SAFE">
            <summary>
            Copy all SAFE chunks.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunkCopyBehaviour.COPY_ALL">
            <summary>
            Copy all chunks (includes palette).
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunkCopyBehaviour.COPY_PHYS">
            <summary>
            Copy Physical resolution (DPI).
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunkCopyBehaviour.COPY_TEXTUAL">
            <summary>
            Copy all textual chunks (not safe).
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunkCopyBehaviour.COPY_TRANSPARENCY">
            <summary>
            Copy transparency (not safe).
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunkCopyBehaviour.COPY_UNKNOWN">
            <summary>
            Copy chunks unknown by our factory.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.ChunkCopyBehaviour.COPY_ALMOSTALL">
            <summary>
            Copy all known, except HIST, TIME and textual.
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.IChunkPredicate">
            <summary>
            Decides if another chunk "matches", according to some criterion.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.IChunkPredicate.Matches(Hjg.Pngcs.Chunks.PngChunk)">
            <summary>
            Whether or not another chunk matches with this one.
            </summary>
            <param name="chunk">The other chunk.</param>
            <returns>true if they match.</returns>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.ChunkPredicateId">
            <summary>
            Match if have same Chunk Id
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.ChunkPredicateId2">
            <summary>
            Match if have same id and, if Text (or SPLT) if have the same key.
            </summary>
            <remarks>
            This is the same as ChunkPredicateEquivalent, the only difference is that does not requires a chunk at construction time.
            </remarks>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.ChunkPredicateEquiv">
            <summary>
            An ad-hoc criterion, perhaps useful, for equivalence.
            <see cref="M:Hjg.Pngcs.Chunks.ChunkHelper.Equivalent(Hjg.Pngcs.Chunks.PngChunk,Hjg.Pngcs.Chunks.PngChunk)"/> 
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkPredicateEquiv.#ctor(Hjg.Pngcs.Chunks.PngChunk)">
            <summary>
            Creates predicate based of reference chunk
            </summary>
            <param name="chunk"></param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.ChunkPredicateEquiv.Matches(Hjg.Pngcs.Chunks.PngChunk)">
            <summary>
            Check for match
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkMultiple">
            <summary>
            A chunk type that allows duplicates of itself in an image.
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkSingle">
            <summary>
            A Chunk type that does not allow duplicate in an image
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngMetadata">
            <summary>
            Image metadata, a wrapper over a <see cref="T:Hjg.Pngcs.Chunks.ChunksList"/>.
            </summary>
            <remarks>
            Additional image info, apart from the ImageInfo and the pixels themselves.<br/>
            Includes Palette and ancillary chunks.<br/>
            This class provides a wrapper over the collection of chunks of a image (read or to write) and provides some high
            level methods to access them.
            </remarks>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.PngMetadata._chunkList">
            <summary>
            The underlying <see cref="T:Hjg.Pngcs.Chunks.ChunksList"/>.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.PngMetadata.ReadOnly">
            <summary>
            Whether or not the metadata is readonly.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngMetadata.QueueChunk(Hjg.Pngcs.Chunks.PngChunk,System.Boolean)">
            <summary>
            Queues the chunk at the writer.
            </summary>
            <param name="chunk">The ready-to-write chunk.</param>
            <param name="lazyOverwrite">Whether or not to overwrite lazily equivalent chunks.</param>
            <remarks>
            Warning: the overwriting applies to equivalent chunks, see <see cref="T:Hjg.Pngcs.Chunks.ChunkPredicateEquiv"/>,
            and will only make sense for queued (not yet writen) chunks.
            </remarks>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngMetadata.QueueChunk(Hjg.Pngcs.Chunks.PngChunk)">
            <summary>
            Queues the chunk at the writer.
            </summary>
            <param name="chunk">The ready-to-write chunk.</param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngMetadata.GetDpi">
            <summary>
            Returns physical resolution, in DPI, in both coordinates
            </summary>
            <returns>[dpix,dpiy], -1 if not set or unknown dimensions</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngMetadata.SetDpi(System.Double,System.Double)">
            <summary>
            Sets physical resolution, in DPI.
            </summary>
            <remarks>This is a utility method that creates and enqueues a PHYS chunk.</remarks>
            <param name="dpix">Resolution in x.</param>
            <param name="dpiy">Resolution in y.</param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngMetadata.SetDpi(System.Double)">
            <summary>
            Sets physical resolution, in DPI, both value in x and y dimensions
            </summary>
            <remarks>This is a utility method that creates and enqueues a PHYS chunk</remarks>
            <param name="dpi">Resolution in dpi</param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngMetadata.SetTimeNow(System.Int32)">
            <summary>
            Creates a TIME chunk,  <c>nsecs</c> in the past from now.
            </summary>
            <param name="nsecs">Seconds in the past. If negative, it's a future time</param>
            <returns>The created and queued chunk</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngMetadata.SetTimeNow">
             <summary>
            Creates a TIME chunk with current time.
             </summary>
             <returns>The created and queued chunk</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngMetadata.SetTimeYMDHMS(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a TIME chunk with given date and time
            </summary>
            <param name="year">Year</param>
            <param name="mon">Month (1-12)</param>
            <param name="day">Day of month (1-31)</param>
            <param name="hour">Hour (0-23)</param>
            <param name="min">Minute (0-59)</param>
            <param name="sec">Seconds (0-59)</param>
            <returns>The created and queued chunk</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngMetadata.GetTime">
            <summary>
            Gets image timestamp, TIME chunk
            </summary>
            <returns>TIME chunk, null if not present</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngMetadata.GetTimeAsString">
            <summary>
            Gets image timestamp, TIME chunk, as a String
            </summary>
            <returns>Formated TIME, empty string if not present</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngMetadata.SetText(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a text chunk and enqueues it
            </summary>
            <param name="key">Key. Short and ASCII string</param>
            <param name="val">Text.</param>
            <param name="useLatin1">Flag. If false, will use UTF-8 (iTXt)</param>
            <param name="compress">Flag. Uses zTXt chunk.</param>
            <returns>The created and enqueued chunk</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngMetadata.SetText(System.String,System.String)">
            <summary>
            Creates a plain text chunk (tEXT) and enqueues it
            </summary>
            <param name="key">Key</param>
            <param name="val">Text</param>
            <returns>The created and enqueued chunk</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngMetadata.GetTxtsForKey(System.String)">
            <summary>
            Retrieves all text chunks with a given key
            </summary>
            <param name="key">Key</param>
            <returns>Empty list if nothing found</returns>
            <remarks>Can mix tEXt zTXt and iTXt chunks</remarks>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngMetadata.GetTxtForKey(System.String)">
            <summary>
            Joins all strings for a given key
            </summary>
            <param name="key">Key</param>
            <returns>Concatenated (with newlines) if several found, empty string if none</returns>
            <remarks>You'd perhaps prefer GetTxtsForKey</remarks>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngMetadata.CreatePLTE">
            <summary>
            Creates a new empty PLTE chunk, queues it for write and return it to the caller, who should fill its entries.
            </summary>
            <returns>A new <see cref="T:Hjg.Pngcs.Chunks.PngChunkPLTE"/>.</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngMetadata.GetTRNS">
            <summary>
            Returns the TRNS chunk or null if not present.
            </summary>
            <returns>A <see cref="T:Hjg.Pngcs.Chunks.PngChunkTRNS"/>.</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngMetadata.CreateTRNS">
            <summary>
            Creates a new empty TRNS chunk, queues it for write and return it to the caller, who should fill its entries.
            </summary>
            <returns>A new <see cref="T:Hjg.Pngcs.Chunks.PngChunkTRNS"/>.</returns>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkSTER">
            <summary>
            sTER chunk: http://www.libpng.org/pub/png/spec/register/pngext-1.3.0-pdg.html#C.sTER
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.Chunks.PngChunkSTER.Mode">
            <summary>
            0: cross-fuse layout 1: diverging-fuse layout
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkOFFS">
            <summary>
            oFFs chunk: http://www.libpng.org/pub/png/spec/register/pngext-1.3.0-pdg.html#C.oFFs
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.Chunks.PngChunkOFFS.Units">
            <summary>
            0 for pixel, 1 for micrometer.
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkSPLT">
            <summary>
            sPLT chunk: http://www.w3.org/TR/PNG/#11sPLT
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.Chunks.PngChunkSPLT.PalName">
            <summary>
            Must be unique in image.
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.Chunks.PngChunkSPLT.SampleDepth">
            <summary>
            The sample depth, 8-16.
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.Chunks.PngChunkSPLT.Palette">
            <summary>
            A color palette with 5 elements per entry.
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkHIST">
            <summary>
            hIST chunk, see http://www.w3.org/TR/PNG/#11hIST
            Only for palette images
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.Chunks.PngChunkHIST.Histogram">
            <summary>
            Should have the same length as the palette.
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkCHRM">
            <summary>
            cHRM chunk, see http://www.w3.org/TR/PNG/#11cHRM
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkSBIT">
            <summary>
            sBIT chunk: http://www.w3.org/TR/PNG/#11sBIT
            
            this chunk structure depends on the image type
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkSRGB">
            <summary>
            sRGB chunk: http://www.w3.org/TR/PNG/#11sRGB
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunk">
            <summary>
            Represents a instance of a PNG chunk
            </summary>
            <remarks>
            Concrete classes should extend <c>PngChunkSingle</c> or <c>PngChunkMultiple</c>
            
            Note that some methods/fields are type-specific (GetOrderingConstraint(), AllowsMultiple())
            some are 'almost' type-specific (Id,Crit,Pub,Safe; the exception is <c>PngUKNOWN</c>), 
            and some are instance-specific
            
            Ref: http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html
            </remarks>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunk.ChunkOrderingConstraint">
            <summary>
            Restrictions for chunk ordering, for ancillary chunks
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.PngChunk.ChunkOrderingConstraint.NONE">
            <summary>
            No constraint, the chunk can go anywhere
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.PngChunk.ChunkOrderingConstraint.BEFORE_PLTE_AND_IDAT">
            <summary>
            Before PLTE (palette) - and hence, also before IDAT
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.PngChunk.ChunkOrderingConstraint.AFTER_PLTE_BEFORE_IDAT">
            <summary>
            After PLTE (palette), but before IDAT
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.PngChunk.ChunkOrderingConstraint.BEFORE_IDAT">
            <summary>
            Before IDAT (before or after PLTE)
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.PngChunk.ChunkOrderingConstraint.NA">
            <summary>
            Does not apply.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.PngChunk.Id">
            <summary>
            4 letters. The Id almost determines the concrete type (except for PngUKNOWN)
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.PngChunk.Critical">
            <summary>
            Whether or not the chunk is critical.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.PngChunk.Public">
            <summary>
            Whether or not the chunk is public.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.PngChunk.Safe">
            <summary>
            Whether or not the chunk is safe to copy.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.PngChunk.ImgInfo">
            <summary>
            Image basic info, mostly for some checks
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.Chunks.PngChunk.Priority">
            <summary>
            For writing. Queued chunks with high priority will be written as soon as possible
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.Chunks.PngChunk.ChunkGroup">
            <summary>
            Chunk group where it was read or writen
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.Chunks.PngChunk.Length">
            <summary>
            Only informational for chunk reads.
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.Chunks.PngChunk.Offset">
            <summary>
            Only informational for chunk reads.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunk.#ctor(System.String,Hjg.Pngcs.ImageInfo)">
            <summary>
            Constructs an empty chunk
            </summary>
            <param name="id"></param>
            <param name="imgInfo"></param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunk.FactoryRegister(System.String,System.Type)">
            <summary>
            Registers a Chunk ID in the factory, to instantiate a given type
            </summary>
            <remarks>
            This can be called by client code to register additional chunk types
            </remarks>
            <param name="chunkId"></param>
            <param name="type">should extend PngChunkSingle or PngChunkMultiple</param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunk.FactoryFromId(System.String,Hjg.Pngcs.ImageInfo)">
            <summary>
            Creates one new blank chunk of the corresponding type, according to factoryMap (PngChunkUNKNOWN if not known)
            </summary>
            <param name="cid">Chunk Id</param>
            <param name="info"></param>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunk.ToString">
            <summary>
            Basic info: Id, length, Type name
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunk.CreateRawChunk">
            <summary>
            Serialization. Creates a Raw chunk, ready for write, from this chunk content
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunk.ParseFromRaw(Hjg.Pngcs.Chunks.ChunkRaw)">
            <summary>
            Deserialization. Given a Raw chunk, just rad, fills this chunk content
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunk.CloneDataFromRead(Hjg.Pngcs.Chunks.PngChunk)">
            <summary>
            Override to make a copy (normally deep) from other chunk
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunk.AllowsMultiple">
            <summary>
            This is implemented in PngChunkMultiple/PngChunSingle
            </summary>
            <returns>Allows more than one chunk of this type in a image</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunk.GetOrderingConstraint">
            <summary>
            Get the ordering constraint, determining where it can be placed.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkBKGD">
            <summary>
            bKGD chunk, see http://www.w3.org/TR/PNG/#11bKGD
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkBKGD.SetGray(System.Int32)">
            <summary>
            Set gray value (0-255 if bitdept=8)
            </summary>
            <param name="gray"></param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkBKGD.GetGray">
            <summary>
            Gets gray value 
            </summary>
            <returns>gray value  (0-255 if bitdept=8)</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkBKGD.SetPaletteIndex(System.Int32)">
            <summary>
            Set pallette index - only for indexed
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkBKGD.GetPaletteIndex">
            <summary>
            Get pallette index - only for indexed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkBKGD.SetRGB(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets rgb value, only for rgb images
            </summary>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkBKGD.GetRGB">
            <summary>
            Gets rgb value, only for rgb images
            </summary>
            <returns>[r , g, b] array</returns>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkGAMA">
            <summary>
            gAMA chunk, see http://www.w3.org/TR/PNG/#11gAMA
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkICCP">
            <summary>
            iCCP Chunk: see http://www.w3.org/TR/PNG/#11iCCP
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkICCP.SetProfileNameAndContent(System.String,System.String)">
            <summary>
            Sets profile name and profile
            </summary>
            <param name="name">profile name </param>
            <param name="profile">profile (latin1 string)</param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkICCP.SetProfileNameAndContent(System.String,System.Byte[])">
            <summary>
            Sets profile name and profile
            </summary>
            <param name="name">profile name </param>
            <param name="profile">profile (uncompressed)</param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkICCP.GetProfile">
            <summary>
            This uncompresses the string!
            </summary>
            <returns></returns>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkIDAT">
            <summary>
            IDAT chunk: http://www.w3.org/TR/PNG/#11IDAT<br/>
            
            This object is dummy placeholder - We treat this chunk in a very different way than ancillary chnks.
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkIEND">
            <summary>
            IEND chunk: http://www.w3.org/TR/PNG/#11IEND
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkIHDR">
            <summary>
            IHDR chunk: http://www.w3.org/TR/PNG/#11IHDR
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkITXT">
            <summary>
            iTXt chunk:  http://www.w3.org/TR/PNG/#11iTXt
            One of the three text chunks
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkUNKNOWN">
            <summary>
            Unknown (for our chunk factory) chunk type.
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkPHYS">
            <summary>
            pHYs chunk: http://www.w3.org/TR/PNG/#11pHYs
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.Chunks.PngChunkPHYS.Units">
            <summary>
            0 for unknown, 1 for meter.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkPHYS.GetAsDpi">
            <summary>
            Returns -1 if not in meters, or not equal.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkPHYS.GetAsDpi2">
            <summary>
            Returns -1 if the physicial unit is unknown.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkPHYS.SetAsDpi(System.Double)">
            <summary>
            Set dpi the same in both directions.
            </summary>
            <param name="dpi">The dpi to set.</param>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkPLTE">
            <summary>
            PLTE Palette chunk: this is the only optional critical chunk.<br/>
            http://www.w3.org/TR/PNG/#11PLTE
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.PngChunkPLTE._length">
            <summary>
            The length of the entries.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.Chunks.PngChunkPLTE.entries">
            <summary>
            The palette entries.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkPLTE.SetLength(System.Int32)">
            <summary>
            Also allocates array.
            </summary>
            <param name="length">1-256</param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkPLTE.GetEntry(System.Int32)">
            <summary>
            Get an entry as a packed RGB8 value.
            </summary>
            <param name="index">The index of the entry.</param>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkPLTE.GetEntryRgb(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Gets the entry at the specified index and splits it among the specified array at the specified offset.
            </summary>
            <param name="index">The index of the entry to get.</param>
            <param name="rgb">The array to fill.</param>
            <param name="offset">The offset to start filling from in the array.</param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkPLTE.GetEntryRgb(System.Int32,System.Int32[])">
            <summary>
            shortcut: GetEntryRgb(index, int[] rgb, 0)
            </summary>
            <param name="n"></param>
            <param name="rgb"></param>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkPLTE.GetColors">
            <summary>
            Gets all the entries as an array of <see cref="T:System.Drawing.Color"/>.
            </summary>
            <returns>An array of <see cref="T:System.Drawing.Color"/>.</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkPLTE.GetColors(System.Byte[])">
            <summary>
            Gets all the entries as an array of <see cref="T:System.Drawing.Color"/>.
            </summary>
            <param name="alpha">The alpha channel from a transparency chunk.</param>
            <returns>An array of <see cref="T:System.Drawing.Color"/>.</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkPLTE.SetColors(System.Drawing.Color[])">
            <summary>
            Sets all the entries in the palette, allocating a new array.
            </summary>
            <param name="colors">The colors to set.</param>
            <exception cref="T:System.ArgumentException">The palette length was invalid.</exception>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkPLTE.GetRgb24">
            <summary>
            Gets all the entries as an array of <see cref="T:Hjg.Pngcs.Drawing.Rgb24"/>.
            </summary>
            <returns>An array of <see cref="T:Hjg.Pngcs.Drawing.Rgb24"/>.</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkPLTE.SetColors(Hjg.Pngcs.Drawing.Rgb24[])">
            <summary>
            Sets all the entries in the palette, allocating a new array.
            </summary>
            <param name="colors">The colors to set.</param>
            <exception cref="T:System.ArgumentException">The palette length was invalid.</exception>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkPLTE.GetRgba32(System.Byte[])">
            <summary>
            Gets all the entries as an array of <see cref="T:Hjg.Pngcs.Drawing.Rgba32"/>.
            </summary>
            <param name="alpha">The alpha channel from a transparency chunk.</param>
            <returns>An array of <see cref="T:Hjg.Pngcs.Drawing.Rgba32"/>.</returns>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkPLTE.SetColors(Hjg.Pngcs.Drawing.Rgba32[])">
            <summary>
            Sets all the entries in the palette, allocating a new array.
            </summary>
            <param name="colors">The colors to set.</param>
            <exception cref="T:System.ArgumentException">The palette length was invalid.</exception>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkPLTE.MinBitDepth">
            <summary>
            Get the minimum allowed bit depth, given the palette size.
            </summary>
            <returns>1-2-4-8</returns>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkTEXT">
            <summary>
            tEXt chunk: latin1 uncompressed text
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkTextVar">
            <summary>
            General class for textual chunks.
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkTIME">
            <summary>
            tIME chunk: http://www.w3.org/TR/PNG/#11tIME
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkTIME.GetAsString">
            <summary>
            format YYYY/MM/DD HH:mm:SS
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkTRNS">
            <summary>
            tRNS chunk: http://www.w3.org/TR/PNG/#11tRNS
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkTRNS.GetPaletteAlpha">
            <summary>
            Warning: Not a deep copy.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkTRNS.SetPaletteAlpha(System.Int32[])">
            <summary>
            Warning: Not a deep copy.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkTRNS.GetPaletteAlphaBytes">
            <summary>
            Get the palette alpha channel as an array of bytes.
            </summary>
            <returns>An array of bytes representing the alpha channel.</returns>
            <exception cref="T:System.InvalidOperationException">Only indexed/palette images support this.</exception>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkTRNS.SetPaletteAlphaBytes(System.Byte[])">
            <summary>
            Set the palette alpha channel with an array of bytes.
            </summary>
            <param name="alpha">An array of bytes representing the alpha channel.</param>
            <exception cref="T:System.InvalidOperationException">Only indexed/palette images support this.</exception>
        </member>
        <member name="M:Hjg.Pngcs.Chunks.PngChunkTRNS.SetIndexEntryAsTransparent(System.Int32)">
            <summary>
            Utility method to use when only one pallete index is set as totally transparent.
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Chunks.PngChunkZTXT">
            <summary>
            zTXt chunk: http://www.w3.org/TR/PNG/#11zTXt
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Drawing.ColorConvert">
            <summary>
            A mass color converter.
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Drawing.ColorDim">
            <summary>
            A color dimension scaler between types.
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.ImageLines">
            <summary>
            Wraps a set of rows from a image, read in a single operation, stored in a int[][] or byte[][] matrix.<br/>
            They can be a subset of the total rows, but in this case they are equispaced.<br/>
            Also see <see cref="T:Hjg.Pngcs.ImageLine"/>.
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.ImageLines.RowCount">
            <summary>
            The number of rows.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.ImageLines.ImageRowToMatrixRow(System.Int32)">
            <summary>
            Translates from image row number to matrix row.
            If you are not sure if this image row in included, use better ImageRowToMatrixRowStrict
            
            </summary>
            <param name="imrow">Row number in the original image (from 0) </param>
            <returns>Row number in the wrapped matrix. Undefined result if invalid</returns>
        </member>
        <member name="M:Hjg.Pngcs.ImageLines.ImageRowToMatrixRowStrict(System.Int32)">
            <summary>
            translates from image row number to matrix row
            </summary>
            <param name="imrow">Row number in the original image (from 0) </param>
            <returns>Row number in the wrapped matrix. Returns -1 if invalid</returns>
        </member>
        <member name="M:Hjg.Pngcs.ImageLines.MatrixRowToImageRow(System.Int32)">
            <summary>
            Translates from matrix row number to real image row number
            </summary>
            <param name="mrow"></param>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.ImageLines.GetImageLineAtMatrixRow(System.Int32)">
            <summary>
            Constructs and returns an ImageLine object backed by a matrix row.
            This is quite efficient, no deep copy.
            </summary>
            <param name="mrow">Row number inside the matrix</param>
            <returns></returns>
        </member>
        <member name="T:Hjg.Pngcs.PngDeinterlacer">
            <summary>
            Deinterlaces read PNG data.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngDeinterlacer._pass">
            <summary>
            Current pass number (1-7).
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngDeinterlacer.AtLastRow">
            <summary>
            Whether or not the current row is the last row for the last pass.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngDeinterlacer.GetCurrentRowSubImage">
            <summary>
            Current row number inside the "sub image"
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngDeinterlacer.GetCurrentRowReal">
            <summary>
            Current row number inside the "real image".
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngDeinterlacer.GetRows">
            <summary>
            How many rows has the current pass?
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngDeinterlacer.GetColumns">
            <summary>
            Get the number of columns (pixels) there are in the current row.
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.FilterWriteStrategy">
            <summary>
            Manages the writer strategy for selecting the internal png predictor filter.
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.PngFileHelper">
            <summary>
            A few utility static methods to read and write files.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngFileHelper.PngOpenRead(System.String)">
            <summary>
            Opens a <see cref="T:Hjg.Pngcs.PngReader"/> with the specified file path.
            </summary>
            <param name="path">The path to the file to read.</param>
            <returns>A <see cref="T:Hjg.Pngcs.PngReader"/>.</returns>
        </member>
        <member name="M:Hjg.Pngcs.PngFileHelper.PngOpenWrite(System.String,Hjg.Pngcs.ImageInfo,System.Boolean)">
            <summary>
            Opens a <see cref="T:Hjg.Pngcs.PngWriter"/> with the specified file path and <see cref="T:Hjg.Pngcs.ImageInfo"/>.</summary>
            <param name="path">The file path to write to.</param>
            <param name="imgInfo">The <see cref="T:Hjg.Pngcs.ImageInfo"/> to set.</param>
            <param name="allowOverwrite">Whether or not to allow overwriting, throwing when not allowed.</param>
            <returns>A <see cref="T:Hjg.Pngcs.PngWriter"/>.</returns>
        </member>
        <member name="T:Hjg.Pngcs.PngCsUtil">
             <summary>
             Utility functions for C# porting.
             </summary>
            
        </member>
        <member name="T:Hjg.Pngcs.ImageInfo">
            <summary>
            Simple immutable wrapper for basic image info.
            </summary>
            <remarks>
            Some parameters are clearly redundant.<br/>
            The constructor requires an 'ortogonal' subset.
            http://www.w3.org/TR/PNG/#11IHDR
            </remarks>
        </member>
        <member name="F:Hjg.Pngcs.ImageInfo.Columns">
            <summary>
            Image width, in pixels
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.ImageInfo.Rows">
            <summary>
            Image height, in pixels
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.ImageInfo.BitDepth">
             <summary>
             Bits per sample (per channel) in the buffer. 
             </summary>
             <remarks>
             This is 8 or 16 for RGB/RGBA images. 
             For grayscale, it's 8 (or 1 2 4 ).
             For indexed images, number of bits per palette index (1 2 4 8).
            </remarks>
        </member>
        <member name="F:Hjg.Pngcs.ImageInfo.Channels">
             <summary>
             The number of channels used in the buffer .
             </summary>
             <remarks>
             WARNING: This is 3-4 for rgb/rgba, but 1 for indexed/grayscale.
            </remarks>
        </member>
        <member name="F:Hjg.Pngcs.ImageInfo.BitsPerPixel">
            <summary>
            Bits used for each pixel in the buffer 
            </summary>
            <remarks>equals <c>channels * bitDepth</c>
            </remarks>
        </member>
        <member name="F:Hjg.Pngcs.ImageInfo.BytesPerPixel">
            <summary>
            Bytes per pixel, rounded up
            </summary>
            <remarks>This is mainly for internal use (filter)</remarks>
        </member>
        <member name="F:Hjg.Pngcs.ImageInfo.BytesPerRow">
            <summary>
            Bytes per row, rounded up
            </summary>
            <remarks>equals <c>ceil(bitspp*cols/8)</c></remarks>
        </member>
        <member name="F:Hjg.Pngcs.ImageInfo.SamplesPerRow">
            <summary>
            Samples (scalar values) per row
            </summary>
            <remarks>
            Equals <c>cols * channels</c>
            </remarks>
        </member>
        <member name="F:Hjg.Pngcs.ImageInfo.SamplesPerRowPacked">
            <summary>
            Number of values in our scanline, which might be packed.
            </summary>
            <remarks>
            Equals samplesPerRow if not packed. Elsewhere, it's lower
            For internal use, mostly.
            </remarks>
        </member>
        <member name="F:Hjg.Pngcs.ImageInfo.HasAlpha">
            <summary>
            Whether or not the image has an alpha channel.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.ImageInfo.Grayscale">
            <summary>
            Whether or not the image is grayscale (G/GA)
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.ImageInfo.Indexed">
            <summary>
            Whether or not the image is indexed and uses a palette.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.ImageInfo.Packed">
            <summary>
            Whether or not there is less than one byte per sample (bitdepths 1,2,4).
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.ImageInfo.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Makes a new RGB/RGBA <see cref="T:Hjg.Pngcs.ImageInfo"/> with the specified settings.
            </summary>
            <param name="columns">Width in pixels</param>
            <param name="rows">Height in pixels</param>
            <param name="bitdepth">Bits per sample per channel</param>
            <param name="hasAlpha">Whether or not it should have an alpha channel.</param>
        </member>
        <member name="M:Hjg.Pngcs.ImageInfo.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Makes a new <see cref="T:Hjg.Pngcs.ImageInfo"/> with the specified settings.
            </summary>
            <param name="columns">Width in pixels</param>
            <param name="rows">Height in pixels</param>
            <param name="bitdepth">Bits per sample per channel</param>
            <param name="hasAlpha">Whether or not it should have an alpha channel.</param>
            <param name="grayscale">Whether or not it should be grayscale.</param>
            <param name="indexed">Whether or not it has a palette and is indexed.</param>
        </member>
        <member name="M:Hjg.Pngcs.ImageInfo.ToString">
            <summary>
            Gets a string representing the image info.
            </summary>
            <returns>A summary of the image info.</returns>
        </member>
        <member name="T:Hjg.Pngcs.ImageLine">
             <summary>
             Lightweight wrapper for an image scanline, for read and write.
             </summary>
             <remarks>It can be (usually it is) reused while iterating over the image lines.<br/>
             See <see cref="P:Hjg.Pngcs.ImageLine.ScanlineInts"/> field doc, to understand the format.
            </remarks>
        </member>
        <member name="T:Hjg.Pngcs.ImageLine.SampleType">
            <summary>
            The sample type of an <see cref="T:Hjg.Pngcs.ImageLine"/>.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.ImageLine.SampleType.Integer">
            <summary>
            4 bytes per sample.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.ImageLine.SampleType.Byte">
            <summary>
            1 byte per sample.
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.ImageLine.ImgInfo">
            <summary>
            ImageInfo (readonly inmutable)
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.ImageLine.ScanlineInts">
            <summary>
            Samples of an image line
            </summary>
            <remarks>
            
            The 'scanline' is an array of integers, corresponds to an image line (row)
            Except for 'packed' formats (gray/indexed with 1-2-4 bitdepth) each int is a
            "sample" (one for channel), (0-255 or 0-65535) in the respective PNG sequence
            sequence : (R G B R G B...) or (R G B A R G B A...) or (g g g ...) or ( i i i
            ) (palette index)
            
            For bitdepth 1/2/4 ,and if samplesUnpacked=false, each value is a PACKED byte! To get an unpacked copy,
            see <c>Pack()</c> and its inverse <c>Unpack()</c>
            
            To convert a indexed line to RGB balues, see ImageLineHelper.PalIdx2RGB()
            (cant do the reverse)
            </remarks>
        </member>
        <member name="P:Hjg.Pngcs.ImageLine.ScanlineBytes">
            <summary>
            Same as Scanline, but with one byte per sample. Only one of ScanlineInts and ScanlineBytes is valid - this depends
            on SampleType}
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.ImageLine.RowNum">
            <summary>
            tracks the current row number (from 0 to rows-1)
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.ImageLine.ElementsPerRow">
            <summary>
            Hown many elements has the scanline array
            =imgInfo.samplePerRowPacked, if packed, imgInfo.samplePerRow elsewhere
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.ImageLine.MaxSampleVal">
            <summary>
            Maximum sample value that this line admits: typically 255; less if bitdepth less than 8, 65535 if 16bits
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.ImageLine.LineSampleType">
            <summary>
            Determines if samples are stored in integers or in bytes
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.ImageLine.SamplesUnpacked">
            <summary>
            True: each scanline element is a sample.
            False: each scanline element has severals samples packed in a byte
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.ImageLine.FilterUsed">
            <summary>
            informational only ; filled by the reader
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.ImageLine.#ctor(Hjg.Pngcs.ImageInfo,Hjg.Pngcs.ImageLine.SampleType,System.Boolean)">
            <summary>
            Creates a new <see cref="T:Hjg.Pngcs.ImageLine"/>.
            </summary>
            <param name="imageInfo">Immutable copy of PNG <see cref="T:Hjg.Pngcs.ImageInfo"/>.</param>
            <param name="sampleType">Storage for samples:INT (default) or BYTE</param>
            <param name="unpackedMode">If true and bitdepth less than 8, samples are unpacked. This has no effect if biddepth 8 or 16.</param>
        </member>
        <member name="M:Hjg.Pngcs.ImageLine.SetScanlineIntsCopy(System.Int32[])">
            <summary>
            Makes a deep copy.
            </summary>
            <remarks>You should rarely use this.</remarks>
        </member>
        <member name="M:Hjg.Pngcs.ImageLine.GetScanlineIntsCopy(System.Int32[])">
            <summary>
            Makes a deep copy.
            </summary>
            <remarks>You should rarely use this.</remarks>
        </member>
        <member name="M:Hjg.Pngcs.ImageLine.GetScanlineInts">
            <summary>
            Gets the current scanline directly.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.ImageLine.GetScanlineBytes">
            <summary>
            Gets the current scanline directly.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.ImageLine.GetUnpackedScanlineInts">
            <summary>
            Gets the current scanline, or an unpacked copy if necessary.
            </summary>
            <returns>The current scanline or an unpacked copy.</returns>
        </member>
        <member name="M:Hjg.Pngcs.ImageLine.GetUnpackedScanlineBytes">
            <summary>
            Gets the current scanline, or an unpacked copy if necessary.
            </summary>
            <returns>The current scanline or an unpacked copy.</returns>
        </member>
        <member name="M:Hjg.Pngcs.ImageLine.SetUnpackedScanlineInts(System.Int32[])">
            <summary>
            Sets the current scanline, packing then using a copy if necessary.
            </summary>
            <param name="line">The line to pack, will not be copied if no packing is needed.</param>
        </member>
        <member name="M:Hjg.Pngcs.ImageLine.SetUnpackedScanlineBytes(System.Byte[])">
            <summary>
            Sets the current scanline, packing then using a copy if necessary.
            </summary>
            <param name="line">The line to pack, will not be copied if no packing is needed.</param>
        </member>
        <member name="T:Hjg.Pngcs.ImageLineHelper">
            <summary>
            Bunch of utility static methods to process/analyze an image line.<br/>
            Not essential at all, some methods are probably to be removed if future releases.<br/>
            TODO: document this better.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.ImageLineHelper.PaletteToRGB(Hjg.Pngcs.ImageLine,Hjg.Pngcs.Chunks.PngChunkPLTE,Hjg.Pngcs.Chunks.PngChunkTRNS,System.Int32[])">
            <summary>
            Given an indexed line with a palette, unpacks as a RGB array
            </summary>
            <param name="line">ImageLine as returned from PngReader</param>
            <param name="pal">Palette chunk</param>
            <param name="trns">TRNS chunk (optional)</param>
            <param name="buf">Preallocated array, optional</param>
            <returns>R G B (one byte per sample)</returns>
        </member>
        <member name="M:Hjg.Pngcs.ImageLineHelper.ClampDouble(System.Double)">
            <summary>
            [0,1)
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.FilterType">
            <summary>
            Internal PNG predictor filter, or a strategy to select it.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.FilterType.FILTER_NONE">
            <summary>
            No filtering 
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.FilterType.FILTER_SUB">
            <summary>
            SUB filter: uses same row
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.FilterType.FILTER_UP">
            <summary>
            UP filter: uses previous row.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.FilterType.FILTER_AVERAGE">
            <summary>
            AVERAGE filter: uses neighbors.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.FilterType.FILTER_PAETH">
            <summary>
            PAETH predictor
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.FilterType.FILTER_DEFAULT">
            <summary>
            Default strategy: select one of the standard filters depending on global image parameters
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.FilterType.FILTER_AGGRESSIVE">
            <summary>
            Aggressive strategy: select dinamically the filters, trying every 8 rows
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.FilterType.FILTER_VERYAGGRESSIVE">
            <summary>
            Very aggressive and slow strategy: tries all filters for each row
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.FilterType.FILTER_CYCLIC">
            <summary>
            Uses all fiters, one for lines, in cyclic way. Only useful for testing.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.FilterType.FILTER_UNKNOWN">
            <summary>
            Not specified, placeholder for unknown or NA filters. 
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.PngHelperInternal">
            <summary>
            Some utility static methods for internal use.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngHelperInternal.GetCRC">
            <summary>
            Thread-singleton crc engine.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngHelperInternal.ReadInt32(System.IO.Stream)">
            <summary>
            Reads a 4-byte integer.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngHelperInternal.ReadBytes(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Guaranteed to read exactly length bytes or it will throw an error.
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.PngIDatChunkInputStream">
            <summary>
            Reads IDAT chunks
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngIDatChunkInputStream.#ctor(System.IO.Stream,System.Int32,System.Int64)">
            <summary>
            Constructor must be called just after reading length and id of first IDAT chunk.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngIDatChunkInputStream.Close">
            <summary>
            Does not close the base stream.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngIDatChunkInputStream.ForceChunkEnd">
            <summary>
            Sometimes last row read does not fully consumes the chunk here we read the remaining dummy bytes.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngIDatChunkInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This can return less than len, but never 0 Returns -1 nothing more to read, -2 if "pseudo file" ended prematurely. That is our error.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngIDatChunkInputStream.DisableCrcCheck">
            <summary>
            Disables CRC checking. This can make reading faster
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.PngIDatChunkOutputStream">
            <summary>
            The output stream for the IDAT chunk, fragmented at a fixed size (32k default).
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.PngReader">
             <summary>
             Reads a PNG image, line by line
             </summary>
             <remarks>
             The typical reading sequence is as follows:<br/>
             <br/>
             1. At construction time, the header and IHDR chunk are read (basic image info)<br/>
             <br/>
             2  (Optional) you can set some global options: UnpackedMode CrcCheckDisabled<br/>
             <br/>
             3. (Optional) If you call GetMetadata() or or GetChunksLisk() before reading the pixels, the chunks before IDAT are automatically loaded and available<br/>
             <br/>
             4a. The rows are read, one by one, with the <tt>ReadRowXXX</tt> methods: (ReadRowInt() , ReadRowByte(), etc)<br/>
             in order, from 0 to nrows-1 (you can skip or repeat rows, but not go backwards)<br/>
             <br/>
             4b. Alternatively, you can read all rows, or a subset, in a single call: see ReadRowsInt(), ReadRowsByte()<br/>
             In general this consumes more memory, but for interlaced images this is equally efficient, and more so if reading a small subset of rows.<br/>
            <br/>
             5. Read of the last row automatically loads the trailing chunks, and ends the reader.<br/>
             <br/>
             6. End() forcibly finishes/aborts the reading and closes the stream<br/>
             </remarks>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._idatInputstream">
            <summary>
            The compression stream.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._iIdatCstream">
            <summary>
            The pixel data stream.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._baseStream">
            <summary>
            The input stream.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._deinterlacer">
            <summary>
            A deinterlacer.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._skipChunkIdsSet">
            <summary>
            The chunks to skip, lazily created.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._metadata">
            <summary>
            A high level wrapper of a ChunksList, or a list of read chunks.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._chunksList">
            <summary>
            Read chunks.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._plte">
            <summary>
            Cache for commonly re-accessed chunk data in read helpers.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._trnsGray8">
            <summary>
            Cache for commonly re-accessed chunk data in read helpers.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._trnsGray16">
            <summary>
            Cache for commonly re-accessed chunk data in read helpers.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._trnsRgb24">
            <summary>
            Cache for commonly re-accessed chunk data in read helpers.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._trnsRgb48">
            <summary>
            Cache for commonly re-accessed chunk data in read helpers.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._plteCacheState">
            <summary>
            The state of the chunk cache.<br/>
            -1 means not searched.<br/>
            0 means searched but not found.<br/>
            1 means found.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._trnsCacheState">
            <summary>
            The state of the chunk cache.<br/>
            -1 means not searched.<br/>
            0 means searched but not found.<br/>
            1 means found.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._imageLine">
            <summary>
            A buffer for the last read image line.
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.PngReader.ImgInfo">
            <summary>
            Basic image info, inmutable.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader.FileName">
            <summary>
            File name, or description, merely informative; can be empty.
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.PngReader.ChunkLoadBehaviour">
            <summary>
            Strategy for chunk loading. Default: LOAD_CHUNK_ALWAYS
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.PngReader.LeaveOpen">
            <summary>
            Whether or not the base stream should be left open.
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.PngReader.MaxBytesMetadata">
            <summary>
            Maximum amount of bytes from ancillary chunks to load in memory 
            </summary>
            <remarks>
             Default: 5MB. 0: unlimited. If exceeded, chunks will be skipped
            </remarks>
        </member>
        <member name="P:Hjg.Pngcs.PngReader.MaxTotalBytesRead">
            <summary>
            Maximum total bytes to read from stream 
            </summary>
            <remarks>
             Default: 200MB. 0: Unlimited. If exceeded, an exception will be thrown
            </remarks>
        </member>
        <member name="P:Hjg.Pngcs.PngReader.SkipChunkMaxSize">
            <summary>
            Maximum ancillary chunk size
            </summary>
            <remarks>
             Default: 2MB, 0: unlimited. Chunks exceeding this size will be skipped (nor even CRC checked)
            </remarks>
        </member>
        <member name="P:Hjg.Pngcs.PngReader.SkipChunkIds">
            <summary>
            Ancillary chunks to skip
            </summary>
            <remarks>
             Default: { "fdAT" }. chunks with these ids will be skipped (nor even CRC checked)
            </remarks>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._rawRow">
            <summary>
            raw current row, as array of bytes,counting from 1 (index 0 is reserved for filter type)
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._previousRawRow">
            <summary>
            The previous raw row.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._filteredRawRow">
            <summary>
            The current raw row unfiltered.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._interlaced">
            <summary>
            Whether or not the PNG was interlaced.
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.PngReader.CrcEnabled">
            <summary>
            Whether or not the CRC check is enabled.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._unpackedMode">
            <summary>
            Whether or not to unpack bitdepths of 1, 2, or 4.
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.PngReader.CurrentChunkGroup">
            <summary>
            number of chunk group (0-6) last read, or currently reading
            </summary>
            <remarks>see ChunksList.CHUNK_GROUP_NNN</remarks>
        </member>
        <member name="F:Hjg.Pngcs.PngReader.LastRowNum">
            <summary>
            Last read row number.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._offset">
            <summary>
            The offset or number of bytes read in the input stream.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngReader._bytesChunksLoaded">
            <summary>
            The number of bytes loaded from ancillary chunks.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngReader.#ctor(System.IO.Stream)">
            <summary>
            Creates a <see cref="T:Hjg.Pngcs.PngReader"/> from a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="input">The input stream.</param>
        </member>
        <member name="M:Hjg.Pngcs.PngReader.#ctor(System.IO.Stream,System.String)">
            <summary>
            Creates a <see cref="T:Hjg.Pngcs.PngReader"/> from a <see cref="T:System.IO.Stream"/> and optional file name or description.
            </summary>
            <remarks>
            The constructor reads the signature and first chunk (IDHR)<br/>
            Also see <see cref="M:Hjg.Pngcs.PngFileHelper.PngOpenRead(System.String)"/>
            </remarks>.
            <param name="input">The input stream.</param>
            <param name="filename">Optional, can be a filename or a description.</param>
        </member>
        <member name="M:Hjg.Pngcs.PngReader.GetChunksList">
            <summary>
            Returns the ancillary chunks available
            </summary>
            <remarks>
            If the rows have not yet still been read, this includes
            only the chunks placed before the pixels (IDAT)
            </remarks>
            <returns>ChunksList</returns>
        </member>
        <member name="M:Hjg.Pngcs.PngReader.GetMetadata">
            <summary>
            Returns the ancillary chunks available.
            </summary>
            <remarks>
            See <see cref="M:Hjg.Pngcs.PngReader.GetChunksList"/>.
            </remarks>
            <returns>A <see cref="T:Hjg.Pngcs.Chunks.PngMetadata"/>.</returns>
        </member>
        <member name="M:Hjg.Pngcs.PngReader.ReadRow(System.Int32)">
             <summary>
             Reads the row using ImageLine as a buffer.
             </summary>
            <param name="nrow">The number of the row to read for checking.</param>
             <returns>The ImageLine that also is available inside this object.</returns>
        </member>
        <member name="M:Hjg.Pngcs.PngReader.ReadFirstChunks">
            <summary>
            Reads chunks before first IDAT.<br/>
            Position before: after IDHR (crc included)<br/>
            Position after: just after the first IDAT chunk id.<br/>
            Returns length of first IDAT chunk, -1 if not found.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngReader.ReadLastChunks">
            <summary>
            Reads (and processes ... up to a point) chunks after last IDAT.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngReader.ReadLastAndClose">
            <summary>
            Internally called after having read the last line. 
            It reads extra chunks after IDAT, if present.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngReader.ReadChunk(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Reads chunkd from input stream, adds to ChunksList, and returns it.
            If it's skipped, a PngChunkSkipped object is created
            </summary>
            <returns>The read <see cref="T:Hjg.Pngcs.Chunks.PngChunk"/>.</returns>
        </member>
        <member name="M:Hjg.Pngcs.PngReader.InitChunkCache">
            <summary>
            If necessary, creates a chunk cache for commonly re-accessed chunk data.
            </summary>
            <exception cref="T:System.Exception">The transparency chunk was not searched for before palette,</exception>
        </member>
        <member name="M:Hjg.Pngcs.PngReader.ReadLineIndices(System.Int32)">
            <summary>
            Reads the next line as an array of indices.
            </summary>
            <param name="nrow">The row number, for checking.</param>
            <returns>An array of indices.</returns>
        </member>
        <member name="M:Hjg.Pngcs.PngReader.GetPaletteColors">
            <summary>
            Gets palette colors, will be an empty array if they could not be found.
            </summary>
            <returns>An array of palette colors.</returns>
        </member>
        <member name="M:Hjg.Pngcs.PngReader.ReadLineColors(System.Int32)">
            <summary>
            Reads the next line as an array of colors, making any transformations necessary.
            </summary>
            <param name="nrow">The row number, for checking.</param>
            <returns>An array of colors.</returns>
            <exception cref="T:System.Exception">Color types were exclusive, the image was indexed but didn't have a palette, or the primary kind of data to read could not be determined.</exception>
        </member>
        <member name="M:Hjg.Pngcs.PngReader.End">
            <summary>
            Normally this does nothing, but it can be used to force a premature closing
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.PngWriter">
            <summary>
             Writes a PNG image, line by line.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngWriter._baseStream">
            <summary>
            The output stream.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngWriter.datStream">
            <summary>
            The pixel data stream.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngWriter.datStreamDeflated">
            <summary>
            The compression stream.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngWriter._filterStrategy">
            <summary>
            The filtering strategy.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngWriter._imageInfo">
            <summary>
            Basic image info, immutable.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngWriter._metadata">
            <summary>
            A high level wrapper of a ChunksList : list of written/queued chunks
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngWriter._chunksList">
            <summary>
            The written/queued chunks.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngWriter.FileName">
            <summary>
            File name, or description, merely informative; can be empty.
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.PngWriter.CompressionStrategy">
            <summary>
            Deflate algortithm compression strategy.
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.PngWriter.CompressionLevel">
            <summary>
            Zip compression level (0 - 9).
            </summary>
            <remarks>
            Default is 6.<br/>
            Maximum is 9.
            </remarks>
        </member>
        <member name="P:Hjg.Pngcs.PngWriter.LeaveOpen">
            <summary>
            Whether or not the base stream should be left open.
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.PngWriter.IdatMaxSize">
            <summary>
            The maximum size of IDAT chunks.
            </summary>
            <remarks>
            0 uses default (PngIDatChunkOutputStream 32768).
            </remarks>
        </member>
        <member name="F:Hjg.Pngcs.PngWriter._rawRow">
            <summary>
            raw current row, as array of bytes,counting from 1 (index 0 is reserved for filter type)
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngWriter._previousRawRow">
            <summary>
            The previous raw row.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngWriter._filteredRawRow">
            <summary>
            The current raw row, after being filtered.
            </summary>
        </member>
        <member name="P:Hjg.Pngcs.PngWriter.CurrentChunkGroup">
            <summary>
            Number of chunk group (0-6) last writen, or currently writing.
            </summary>
            <remarks>see ChunksList.CHUNK_GROUP_NNN</remarks>
        </member>
        <member name="F:Hjg.Pngcs.PngWriter._rowNum">
            <summary>
            Current line number.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngWriter.histox">
            <summary>
            Auxiliar buffer, histogram, only used by <see cref="M:Hjg.Pngcs.PngWriter.ReportResultsForFilter(System.Int32,Hjg.Pngcs.FilterType,System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngWriter._unpackedMode">
            <summary>
            This only influences the 1-2-4 bitdepth format; If we pass a ImageLine to WriteRow, this is ignored.
            </summary>
        </member>
        <member name="F:Hjg.Pngcs.PngWriter.needsPack">
            <summary>
            Whether or not values need to be packed, is auto computed.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngWriter.#ctor(System.IO.Stream,Hjg.Pngcs.ImageInfo)">
            <summary>
            Creates a <see cref="T:Hjg.Pngcs.PngWriter"/> from a <see cref="T:System.IO.Stream"/> and <see cref="T:Hjg.Pngcs.ImageInfo"/>.
            </summary>
            <param name="output">The output stream.</param>
            <param name="imgInfo">The image info.</param>
        </member>
        <member name="M:Hjg.Pngcs.PngWriter.#ctor(System.IO.Stream,Hjg.Pngcs.ImageInfo,System.String)">
            <summary>
            Creates a <see cref="T:Hjg.Pngcs.PngWriter"/> from a <see cref="T:System.IO.Stream"/>, <see cref="T:Hjg.Pngcs.ImageInfo"/>, and optional file name or description.
            </summary>
            <remarks>
            After construction nothing is written yet.<br/>
            You still can set some parameters (compression, filters) and queue chunks before you start writing the pixels.<br/>
            Also see <see cref="M:Hjg.Pngcs.PngFileHelper.PngOpenWrite(System.String,Hjg.Pngcs.ImageInfo,System.Boolean)"/>.
            </remarks>
            <param name="output">The output stream.</param>
            <param name="imageInfo">The image info.</param>
            <param name="filename">Optional, can be a filename or a description.</param>
        </member>
        <member name="M:Hjg.Pngcs.PngWriter.GetMetadata">
            <summary>
            Gets the <see cref="T:Hjg.Pngcs.Chunks.PngMetadata"/>.
            </summary>
            <returns>A <see cref="T:Hjg.Pngcs.Chunks.PngMetadata"/>.</returns>
        </member>
        <member name="M:Hjg.Pngcs.PngWriter.GetChunksList">
            <summary>
            Gets the chunks list to be written.
            </summary>
            <returns>A <see cref="T:Hjg.Pngcs.Chunks.ChunksListForWrite"/>.</returns>
        </member>
        <member name="M:Hjg.Pngcs.PngWriter.IsUnpackedMode">
            <summary>
            Whether or not unpacked mode is set.<br/>
            This determines whether or not packed values (bitdepths 1,2,4) will be written unpacked.
            </summary>
            <returns>Whether or not unpacked mode is set.</returns>
        </member>
        <member name="M:Hjg.Pngcs.PngWriter.SetUnpackedMode(System.Boolean)">
            <summary>
            Sets unpacked mode to the specified state.
            </summary>
            <param name="value">The value to set.</param>
        </member>
        <member name="M:Hjg.Pngcs.PngWriter.ComputeCompressionRatio">
            <summary>
            Computes compressed size/raw size, approximate
            </summary>
            <remarks>Actually: compressed size = total size of IDAT data , raw size = uncompressed pixel bytes = rows * (bytesPerRow + 1)
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Hjg.Pngcs.PngWriter.Init">
            <summary>
            This is called automatically before writing the first row.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngWriter.WriteSignatureAndIHDR">
            <summary>
            Write id signature and also "IHDR" chunk
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngWriter.WriteRow(Hjg.Pngcs.ImageLine,System.Int32)">
            <summary>
            Write a <see cref="T:Hjg.Pngcs.ImageLine"/>.<br/>
            This uses the row number from the <see cref="T:Hjg.Pngcs.ImageLine"/>.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngWriter.WriteRowInt(System.Int32[],System.Int32)">
            <summary>
            Writes a full image row.
            </summary>
            <remarks>
            This must be called sequentially from n=0 to n=rows-1.<br/>
            There must be one integer per sample.<br/>
            They must be in order: R G B R G B ... (or R G B A R G B A... if it has alpha).<br/>
            The values should be between 0 and 255 for 8 bitsperchannel images,<br/>
            and between 0-65535 form 16 bitsperchannel images (this applies also to the alpha channel if present)<br/>
            The array can be reused.
            </remarks>
            <param name="newrow">The pixel values to write.</param>
            <param name="rowNum">The number of the row, from 0 at the top, to rows - 1 at the bottom.</param>
        </member>
        <member name="M:Hjg.Pngcs.PngWriter.WriteRowByte(System.Byte[],System.Int32)">
            <summary>
            Writes a full image row of bytes.
            </summary>
            <param name="newrow">The pixel values to write.</param>
            <param name="rowNum"></param>
        </member>
        <member name="M:Hjg.Pngcs.PngWriter.WriteRowsInt(System.Int32[][])">
            <summary>
            Writes all the pixels, calling <see cref="M:Hjg.Pngcs.PngWriter.WriteRowInt(System.Int32[],System.Int32)"/> for each image row
            </summary>
            <param name="image">The image to write.</param>
        </member>
        <member name="M:Hjg.Pngcs.PngWriter.WriteRowsByte(System.Byte[][])">
            <summary>
            Writes all the pixels, calling <see cref="M:Hjg.Pngcs.PngWriter.WriteRowByte(System.Byte[],System.Int32)"/> for each image row.
            </summary>
            <param name="image">The image to write.</param>
        </member>
        <member name="M:Hjg.Pngcs.PngWriter.SetFilterType(Hjg.Pngcs.FilterType)">
            <summary>
            Sets internal prediction filter type, or a strategy to choose it.
            </summary>
            <remarks>
            This must be called just after constructor, before starting writing.<br/>
            Recommended values: DEFAULT (default) or AGGRESSIVE.
            </remarks>
            <param name="filterType">One of the five prediction types or strategy to choose it</param>
        </member>
        <member name="M:Hjg.Pngcs.PngWriter.CopyChunks(Hjg.Pngcs.PngReader,System.Int32,System.Boolean)">
            <summary>
            Copy chunks from reader - copyMask : see ChunksToWrite.COPY_XXX.<br/>
            If we are after idat, only considers those chunks after IDAT in <see cref="T:Hjg.Pngcs.PngReader"/>.<br/>
            TODO: this should be more customizable.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.PngWriter.End">
            <summary>
            Finalizes the image creation and closes the file stream.
            </summary>
            <remarks>This must be called after writing all lines.</remarks>
        </member>
        <member name="T:Hjg.Pngcs.ProgressiveOutputStream">
            <summary>
            A stream that outputs to memory and allows to flush fragments every 'size' bytes to some other destination.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.ProgressiveOutputStream.CheckFlushBuffer(System.Boolean)">
            <summary>
            If it's time to flush data (or if forced==true) calls abstract method FlushBuffer() and cleans those bytes from own buffer.
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Zlib.ICSZlibOutputStream">
            <summary>
            Zlib output (deflater) based on SharpZipLib.
            </summary>
        </member>
        <member name="T:Hjg.Pngcs.Zlib.ICSZlibInputStream">
            <summary>
            Zip input (inflater) based on SharpZipLib.
            </summary>
        </member>
        <member name="M:Hjg.Pngcs.Zlib.ZlibInputStream.GetImplementationId">
            <summary>
            Mainly for debugging.
            </summary>
            <returns>The ImplementationId.</returns>
        </member>
        <member name="M:Hjg.Pngcs.Zlib.ZlibOutputStream.GetImplementationId">
            <summary>
            Mainly for debugging.
            </summary>
            <returns>The ImplementationId.</returns>
        </member>
    </members>
</doc>
